# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.5.1

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class GOFPFacet:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "GOFPFacet"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("GOFPFacet")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(self, transaction_config):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(transaction_config)
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def admin_terminus_info(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.adminTerminusInfo.call(block_identifier=block_number)

    def choose_current_stage_paths(
        self, session_id: int, token_ids: List, paths: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.chooseCurrentStagePaths(
            session_id, token_ids, paths, transaction_config
        )

    def create_session(
        self,
        player_token_address: ChecksumAddress,
        payment_token_address: ChecksumAddress,
        payment_amount: int,
        is_active: bool,
        uri: str,
        stages: List,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.createSession(
            player_token_address,
            payment_token_address,
            payment_amount,
            is_active,
            uri,
            stages,
            transaction_config,
        )

    def get_correct_path_for_stage(
        self,
        session_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getCorrectPathForStage.call(
            session_id, stage, block_identifier=block_number
        )

    def get_current_stage(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getCurrentStage.call(
            session_id, block_identifier=block_number
        )

    def get_path_choice(
        self,
        session_id: int,
        token_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getPathChoice.call(
            session_id, token_id, stage, block_identifier=block_number
        )

    def get_session(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getSession.call(session_id, block_identifier=block_number)

    def get_stage_reward(
        self,
        session_id: int,
        stage: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getStageReward.call(
            session_id, stage, block_identifier=block_number
        )

    def get_staked_token_info(
        self,
        nft_address: ChecksumAddress,
        token_id: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getStakedTokenInfo.call(
            nft_address, token_id, block_identifier=block_number
        )

    def init(
        self,
        admin_terminus_address: ChecksumAddress,
        admin_terminus_pool_id: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.init(
            admin_terminus_address, admin_terminus_pool_id, transaction_config
        )

    def num_sessions(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.numSessions.call(block_identifier=block_number)

    def num_tokens_staked_into_session(
        self,
        session_id: int,
        staker: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.numTokensStakedIntoSession.call(
            session_id, staker, block_identifier=block_number
        )

    def on_erc1155_batch_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: List,
        arg4: List,
        arg5: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC1155BatchReceived(
            arg1, arg2, arg3, arg4, arg5, transaction_config
        )

    def on_erc1155_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: int,
        arg4: int,
        arg5: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC1155Received(
            arg1, arg2, arg3, arg4, arg5, transaction_config
        )

    def on_erc721_received(
        self,
        arg1: ChecksumAddress,
        arg2: ChecksumAddress,
        arg3: int,
        arg4: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.onERC721Received(
            arg1, arg2, arg3, arg4, transaction_config
        )

    def set_correct_path_for_stage(
        self,
        session_id: int,
        stage: int,
        path: int,
        set_is_choosing_active: bool,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setCorrectPathForStage(
            session_id, stage, path, set_is_choosing_active, transaction_config
        )

    def set_session_active(
        self, session_id: int, is_active: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionActive(session_id, is_active, transaction_config)

    def set_session_choosing_active(
        self, session_id: int, is_choosing_active: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionChoosingActive(
            session_id, is_choosing_active, transaction_config
        )

    def set_session_uri(self, session_id: int, uri: str, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setSessionUri(session_id, uri, transaction_config)

    def set_stage_rewards(
        self,
        session_id: int,
        stages: List,
        terminus_addresses: List,
        terminus_pool_ids: List,
        reward_amounts: List,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setStageRewards(
            session_id,
            stages,
            terminus_addresses,
            terminus_pool_ids,
            reward_amounts,
            transaction_config,
        )

    def stake_tokens_into_session(
        self, session_id: int, token_ids: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.stakeTokensIntoSession(
            session_id, token_ids, transaction_config
        )

    def supports_interface(
        self, interface_id: bytes, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.supportsInterface.call(
            interface_id, block_identifier=block_number
        )

    def token_of_staker_in_session_by_index(
        self,
        session_id: int,
        staker: ChecksumAddress,
        index: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.tokenOfStakerInSessionByIndex.call(
            session_id, staker, index, block_identifier=block_number
        )

    def unstake_tokens_from_session(
        self, session_id: int, token_ids: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.unstakeTokensFromSession(
            session_id, token_ids, transaction_config
        )


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = GOFPFacet(None)
    result = contract.deploy(transaction_config=transaction_config)
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.verify_contract()
    print(result)


def handle_admin_terminus_info(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.admin_terminus_info(block_number=args.block_number)
    print(result)


def handle_choose_current_stage_paths(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.choose_current_stage_paths(
        session_id=args.session_id,
        token_ids=args.token_ids,
        paths=args.paths,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_create_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.create_session(
        player_token_address=args.player_token_address,
        payment_token_address=args.payment_token_address,
        payment_amount=args.payment_amount,
        is_active=args.is_active,
        uri=args.uri,
        stages=args.stages,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_get_correct_path_for_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_correct_path_for_stage(
        session_id=args.session_id, stage=args.stage, block_number=args.block_number
    )
    print(result)


def handle_get_current_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_current_stage(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_get_path_choice(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_path_choice(
        session_id=args.session_id,
        token_id=args.token_id,
        stage=args.stage,
        block_number=args.block_number,
    )
    print(result)


def handle_get_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_session(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_get_stage_reward(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_stage_reward(
        session_id=args.session_id, stage=args.stage, block_number=args.block_number
    )
    print(result)


def handle_get_staked_token_info(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.get_staked_token_info(
        nft_address=args.nft_address,
        token_id=args.token_id,
        block_number=args.block_number,
    )
    print(result)


def handle_init(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.init(
        admin_terminus_address=args.admin_terminus_address,
        admin_terminus_pool_id=args.admin_terminus_pool_id,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_num_sessions(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.num_sessions(block_number=args.block_number)
    print(result)


def handle_num_tokens_staked_into_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.num_tokens_staked_into_session(
        session_id=args.session_id, staker=args.staker, block_number=args.block_number
    )
    print(result)


def handle_on_erc1155_batch_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc1155_batch_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        arg5=args.arg5,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_erc1155_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc1155_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        arg5=args.arg5,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_on_erc721_received(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.on_erc721_received(
        arg1=args.arg1,
        arg2=args.arg2,
        arg3=args.arg3,
        arg4=args.arg4,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_correct_path_for_stage(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_correct_path_for_stage(
        session_id=args.session_id,
        stage=args.stage,
        path=args.path,
        set_is_choosing_active=args.set_is_choosing_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_active(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_active(
        session_id=args.session_id,
        is_active=args.is_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_choosing_active(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_choosing_active(
        session_id=args.session_id,
        is_choosing_active=args.is_choosing_active,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_session_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_session_uri(
        session_id=args.session_id, uri=args.uri, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_stage_rewards(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_stage_rewards(
        session_id=args.session_id,
        stages=args.stages,
        terminus_addresses=args.terminus_addresses,
        terminus_pool_ids=args.terminus_pool_ids,
        reward_amounts=args.reward_amounts,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_stake_tokens_into_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.stake_tokens_into_session(
        session_id=args.session_id,
        token_ids=args.token_ids,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_supports_interface(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.supports_interface(
        interface_id=args.interface_id, block_number=args.block_number
    )
    print(result)


def handle_token_of_staker_in_session_by_index(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    result = contract.token_of_staker_in_session_by_index(
        session_id=args.session_id,
        staker=args.staker,
        index=args.index,
        block_number=args.block_number,
    )
    print(result)


def handle_unstake_tokens_from_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = GOFPFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.unstake_tokens_from_session(
        session_id=args.session_id,
        token_ids=args.token_ids,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for GOFPFacet")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    admin_terminus_info_parser = subcommands.add_parser("admin-terminus-info")
    add_default_arguments(admin_terminus_info_parser, False)
    admin_terminus_info_parser.set_defaults(func=handle_admin_terminus_info)

    choose_current_stage_paths_parser = subcommands.add_parser(
        "choose-current-stage-paths"
    )
    add_default_arguments(choose_current_stage_paths_parser, True)
    choose_current_stage_paths_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    choose_current_stage_paths_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    choose_current_stage_paths_parser.add_argument(
        "--paths", required=True, help="Type: uint256[]", nargs="+"
    )
    choose_current_stage_paths_parser.set_defaults(
        func=handle_choose_current_stage_paths
    )

    create_session_parser = subcommands.add_parser("create-session")
    add_default_arguments(create_session_parser, True)
    create_session_parser.add_argument(
        "--player-token-address", required=True, help="Type: address"
    )
    create_session_parser.add_argument(
        "--payment-token-address", required=True, help="Type: address"
    )
    create_session_parser.add_argument(
        "--payment-amount", required=True, help="Type: uint256", type=int
    )
    create_session_parser.add_argument(
        "--is-active", required=True, help="Type: bool", type=boolean_argument_type
    )
    create_session_parser.add_argument(
        "--uri", required=True, help="Type: string", type=str
    )
    create_session_parser.add_argument(
        "--stages", required=True, help="Type: uint256[]", nargs="+"
    )
    create_session_parser.set_defaults(func=handle_create_session)

    get_correct_path_for_stage_parser = subcommands.add_parser(
        "get-correct-path-for-stage"
    )
    add_default_arguments(get_correct_path_for_stage_parser, False)
    get_correct_path_for_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_correct_path_for_stage_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_correct_path_for_stage_parser.set_defaults(
        func=handle_get_correct_path_for_stage
    )

    get_current_stage_parser = subcommands.add_parser("get-current-stage")
    add_default_arguments(get_current_stage_parser, False)
    get_current_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_current_stage_parser.set_defaults(func=handle_get_current_stage)

    get_path_choice_parser = subcommands.add_parser("get-path-choice")
    add_default_arguments(get_path_choice_parser, False)
    get_path_choice_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_path_choice_parser.set_defaults(func=handle_get_path_choice)

    get_session_parser = subcommands.add_parser("get-session")
    add_default_arguments(get_session_parser, False)
    get_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_session_parser.set_defaults(func=handle_get_session)

    get_stage_reward_parser = subcommands.add_parser("get-stage-reward")
    add_default_arguments(get_stage_reward_parser, False)
    get_stage_reward_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_stage_reward_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    get_stage_reward_parser.set_defaults(func=handle_get_stage_reward)

    get_staked_token_info_parser = subcommands.add_parser("get-staked-token-info")
    add_default_arguments(get_staked_token_info_parser, False)
    get_staked_token_info_parser.add_argument(
        "--nft-address", required=True, help="Type: address"
    )
    get_staked_token_info_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    get_staked_token_info_parser.set_defaults(func=handle_get_staked_token_info)

    init_parser = subcommands.add_parser("init")
    add_default_arguments(init_parser, True)
    init_parser.add_argument(
        "--admin-terminus-address", required=True, help="Type: address"
    )
    init_parser.add_argument(
        "--admin-terminus-pool-id", required=True, help="Type: uint256", type=int
    )
    init_parser.set_defaults(func=handle_init)

    num_sessions_parser = subcommands.add_parser("num-sessions")
    add_default_arguments(num_sessions_parser, False)
    num_sessions_parser.set_defaults(func=handle_num_sessions)

    num_tokens_staked_into_session_parser = subcommands.add_parser(
        "num-tokens-staked-into-session"
    )
    add_default_arguments(num_tokens_staked_into_session_parser, False)
    num_tokens_staked_into_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    num_tokens_staked_into_session_parser.add_argument(
        "--staker", required=True, help="Type: address"
    )
    num_tokens_staked_into_session_parser.set_defaults(
        func=handle_num_tokens_staked_into_session
    )

    on_erc1155_batch_received_parser = subcommands.add_parser(
        "on-erc1155-batch-received"
    )
    add_default_arguments(on_erc1155_batch_received_parser, True)
    on_erc1155_batch_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256[]", nargs="+"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg4", required=True, help="Type: uint256[]", nargs="+"
    )
    on_erc1155_batch_received_parser.add_argument(
        "--arg5", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc1155_batch_received_parser.set_defaults(func=handle_on_erc1155_batch_received)

    on_erc1155_received_parser = subcommands.add_parser("on-erc1155-received")
    add_default_arguments(on_erc1155_received_parser, True)
    on_erc1155_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc1155_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc1155_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256", type=int
    )
    on_erc1155_received_parser.add_argument(
        "--arg4", required=True, help="Type: uint256", type=int
    )
    on_erc1155_received_parser.add_argument(
        "--arg5", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc1155_received_parser.set_defaults(func=handle_on_erc1155_received)

    on_erc721_received_parser = subcommands.add_parser("on-erc721-received")
    add_default_arguments(on_erc721_received_parser, True)
    on_erc721_received_parser.add_argument(
        "--arg1", required=True, help="Type: address"
    )
    on_erc721_received_parser.add_argument(
        "--arg2", required=True, help="Type: address"
    )
    on_erc721_received_parser.add_argument(
        "--arg3", required=True, help="Type: uint256", type=int
    )
    on_erc721_received_parser.add_argument(
        "--arg4", required=True, help="Type: bytes", type=bytes_argument_type
    )
    on_erc721_received_parser.set_defaults(func=handle_on_erc721_received)

    set_correct_path_for_stage_parser = subcommands.add_parser(
        "set-correct-path-for-stage"
    )
    add_default_arguments(set_correct_path_for_stage_parser, True)
    set_correct_path_for_stage_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--stage", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--path", required=True, help="Type: uint256", type=int
    )
    set_correct_path_for_stage_parser.add_argument(
        "--set-is-choosing-active",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    set_correct_path_for_stage_parser.set_defaults(
        func=handle_set_correct_path_for_stage
    )

    set_session_active_parser = subcommands.add_parser("set-session-active")
    add_default_arguments(set_session_active_parser, True)
    set_session_active_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_active_parser.add_argument(
        "--is-active", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_session_active_parser.set_defaults(func=handle_set_session_active)

    set_session_choosing_active_parser = subcommands.add_parser(
        "set-session-choosing-active"
    )
    add_default_arguments(set_session_choosing_active_parser, True)
    set_session_choosing_active_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_choosing_active_parser.add_argument(
        "--is-choosing-active",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    set_session_choosing_active_parser.set_defaults(
        func=handle_set_session_choosing_active
    )

    set_session_uri_parser = subcommands.add_parser("set-session-uri")
    add_default_arguments(set_session_uri_parser, True)
    set_session_uri_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_session_uri_parser.add_argument(
        "--uri", required=True, help="Type: string", type=str
    )
    set_session_uri_parser.set_defaults(func=handle_set_session_uri)

    set_stage_rewards_parser = subcommands.add_parser("set-stage-rewards")
    add_default_arguments(set_stage_rewards_parser, True)
    set_stage_rewards_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    set_stage_rewards_parser.add_argument(
        "--stages", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--terminus-addresses", required=True, help="Type: address[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--terminus-pool-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.add_argument(
        "--reward-amounts", required=True, help="Type: uint256[]", nargs="+"
    )
    set_stage_rewards_parser.set_defaults(func=handle_set_stage_rewards)

    stake_tokens_into_session_parser = subcommands.add_parser(
        "stake-tokens-into-session"
    )
    add_default_arguments(stake_tokens_into_session_parser, True)
    stake_tokens_into_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    stake_tokens_into_session_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    stake_tokens_into_session_parser.set_defaults(func=handle_stake_tokens_into_session)

    supports_interface_parser = subcommands.add_parser("supports-interface")
    add_default_arguments(supports_interface_parser, False)
    supports_interface_parser.add_argument(
        "--interface-id", required=True, help="Type: bytes4", type=bytes_argument_type
    )
    supports_interface_parser.set_defaults(func=handle_supports_interface)

    token_of_staker_in_session_by_index_parser = subcommands.add_parser(
        "token-of-staker-in-session-by-index"
    )
    add_default_arguments(token_of_staker_in_session_by_index_parser, False)
    token_of_staker_in_session_by_index_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    token_of_staker_in_session_by_index_parser.add_argument(
        "--staker", required=True, help="Type: address"
    )
    token_of_staker_in_session_by_index_parser.add_argument(
        "--index", required=True, help="Type: uint256", type=int
    )
    token_of_staker_in_session_by_index_parser.set_defaults(
        func=handle_token_of_staker_in_session_by_index
    )

    unstake_tokens_from_session_parser = subcommands.add_parser(
        "unstake-tokens-from-session"
    )
    add_default_arguments(unstake_tokens_from_session_parser, True)
    unstake_tokens_from_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    unstake_tokens_from_session_parser.add_argument(
        "--token-ids", required=True, help="Type: uint256[]", nargs="+"
    )
    unstake_tokens_from_session_parser.set_defaults(
        func=handle_unstake_tokens_from_session
    )

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
